尊敬的各位来宾，软件同行们，大家下午好。我叫吕靖，大家也可以叫我 Jimmy，我呢？之前在 ThoughtWorks 思特沃克和阿里巴巴工作过，目前在 Parabol 创业，专注于敏捷会议工具，致力于让未来的工作更有意义。

非常高兴来参加本次创新峰会，与各位分享「API 的未来：graphql 如何为敏捷组织铺平道路」，让我们翻开目录。今天我会给大家从 4 个方面来介绍全面介绍 GraphQL，结构非常简单，第一部分是 What & How： API 的未来跟敏捷，也就是未来组织，会碰撞出什么样的火花。第二部分是 How：我介绍如何实践 GraphQL，直接分享 4 个工程实践的经验。以及第三部分，Where，在什么样的真实的应用场景下，结合具体的软件功能和代码实践，来介绍 4 个具体的真实案例。最后，我会总结一下 graphql 是怎么帮助我们公司进行异步协作的，作为一个敏捷组织，我们自身，就一直在探索未来的研发模式，和未来的工作方式。

好，那么让我们进入第一部分， API 的未来与敏捷组织。首先什么是 graphql API，GraphQL 后面的 QL 就是 query language，它是以一种声明式的语言描述 API 对数据的需求。比方说这里有一个简单的图例，第一步定义 Schema 也就是数据的需求，第二步，你就可以去请求任意你想要的数据的结构，第三步，API 返回可预测的数据的结果。因为 GraphQL 是基于类型的，所以所有的数据结构和数据类型都是可预测的。

简单的介绍之后，有朋友就会问了，为什么我们要用 graphql，现在的 REST API 难道还不够好吗？那么，让我们先来看一个简单的案例，大家是否有购买汽车的体验呢？想象一下，如果切换一下视角，当你作为销售人员，为买车的客户去办理汽车贷款。在这个场景下，我们来思考一下，总共会有几种不同的对象呢？

左边是客户要买的汽车，它会有不同的类型，车的型号、车的大小，以及否是新能源等等一些属性。以及右边，可以看到我们需要向银行和车管所去请求客户的信息，比方说客户姓名、信用情况、是否有驾照等一些基本的信息。所以在这样一个数据聚合的场景下，我们可以发现汽车、客户、银行这三种不同的对象，分别需要去三种不同的渠道都需要去请求对应的数据。

像以往，如果是使用 rest API，就分别需要去请求不同的 resource 也就是资源，每个资源对应不同的数据结构。而 graphql 就是一种 rest API 的替代，可以通过 schema 所定义的数据类型和数据结构，直接得到我们想要的一种聚合的结果，也就是所有想要的数据一次性就返回回来了。

这会有什么好处呢？解决了什么问题呢？GraphQL 解决的第一个问题是请求不足，也就是 under-fetching，这意味着，当我们去请求数据时，比如在先前的例子当中关于客户的个人信息的时候，发现 /API/user 就只能拿到 user 的名字，比方说我叫吕靖，但是当需要请求我住在哪里时，我的 address 地址是什么的时候，就会发现我们不得不去借助于第二个 API 也就是 /API/address，通过 user ID 再一次请求 address API 才能够拿到我的家庭住址。

所以，这里的问题在于，客户端无法一次性获得所有对数据的需求，而是在后边通过两个 API 共同去获取到所有的数据。可想而知，这只是一个非常简单的用例。当你需要请求更多的数据，比方说还需要个人的身份证、驾驶证等信息，银行的信用信息、汽车所对应的型号信息，你是不是在脑海中就想到了非常多的 API 的路径需要去请求？而且还可能出现请求顺序的各种复杂情况呢？

而我们再看右边，这是 graphql 的 API，它只需要 /graphql 这样一个端口，就可以获取到先前提到的所有的数据。比方说这里的 user 用户的名字以及住址、居住城市等等就一次性被返回回来了。

结构是不是非常的简单？

我们再来看下一个，跟 Under-Fetching 请求不足相对的，GraphQL 解决的第二个问题是 Over-Fetching 请求过度，当我们去请求 API 的时候，因为后端无法预知前端页面所需要的到底有哪些数据，所以一般情况下 API 都只能一次性把所有的数据都返回回来。比方说，右下角这张图是一个 API 返回的所有数据，当我们需要从这个数据结构里面，去找个某个人的名字的时候，是不是需要去找很多很多的层级，才能发现它具体的位置。如果说每次对数据的请求只需要那么一个字段，但是后端 API 却会返回非常多的其他字段。这种超额的数据获取，就导致了信息的冗余，浪费服务器和客户端之间的网络资源，这还只是一方面，让我们拆分来看。

第一点是，GraphQL 能够满足按需获取数据，减少网络请求的开销。第二点是，当不同的页面需要不同的数据的时候，可想而知，后端 API 无法同时对应多个页面，不同的数据差异化。那这个时候，难道我们的后端 API 要为前端每个页面去定制化不同的 API 吗？如果这样的话，会造成了更大的浪费。第三个场景是，随着业务需求的不断变化，API 本身也有渐进式的改进迭代的需求，因此 API 在不同版本之间可能需要返回不同的数据。比方说，从客户的老身份证到新身份证这样一个字段，需要迁移。那以前的话，就需要在 API 层面上直接做两个字段的区分，或者通过加参数字段等等，而这样反而导致了另外一个层面的复杂度。而在 graphql 里面，你就可以简单的用标识符直接标识，该字段已经被新字段替代了。

好，刚刚从 2 个 API 的问题出发，介绍了什么是 GraphQL 以及 GraphQL 是如何解决问题的，我来总结一下，为什么 GraphQL 可以助力于敏捷组织，我们得点题，对吧？首先呢，我们得思考，为什么我们的产品需求会经常发生变化？这里的大背景肯定就是因为，在 21 世纪 VUCA 的市场大环境下，VUCA 也就是易变性、不确定性、复杂性和模糊性的英文缩写哈，在不断变化的时代大背景下，越来越多的企业组织，就是在主动或被迫的放弃长期而精密的预先计划，转而使用快速迭代的方式，以满足市场的需求。不得不说打造敏捷组织是时代背景下企业的应对之策。

所以，graphql 在这样的背景下，从 API 层面，非常漂亮地解决了 3 个重要问题。首先是按需返回数据：在填充页面数据的时候，需要多次返回网络请求，GraphQL 一次性就把客户端页面所需要的数据一次性返回回来了，显然就优化了网络请求的速度，也能够更快的为我们的用户呈现具体的页面。

而 GraphQL 解决的第 2 个问题在于，客户端与服务端相互依赖，没办法解耦，因为这里的客户端不只是前端，比方说小程序端、网页端、移动端，甚至未来随着智能汽车的普及，车机系统也会发展越来越迅速，而车机上面显示的内容跟手机端、 web 端可能都有所不同。以前，后端需要为不同的客户端去定制不同的 API，每个客户端也需要适配不同的后端 API，从而导致了客户端持续地依赖服务端，根本没办法解耦。而 GraphQL 就非常漂亮地解决了这个问题，可以按照前端所需要的数据需求，按需地返回数据，并且不同的客户端需要哪些数据，是由它自己来定义的。

GraphQL 解决的第 3 个问题，则是开发效率层面的，GraphQL 从 API 层面解决了糟糕的前端开发体验。就像前面提到的，市场在变化，用户需求的变化也是非常频繁的，而 graphql 能够帮助前端开发在这样极其频繁的数据变化情况下轻松应对。

总结下来，这 3 个问题的核心点都可以归结于「耦合」。而「解耦合」对于「应对变化」是至关重要的，尤其是对咱们的敏捷组织而言：首先用户体验很重要，GraphQL 在网络层面直接优化了网络请求的次数。第 2 个是在客户端非常多的情况下，我们需要在不同的应用场景下应对用户的需求，使用一个 /graphql API 就在不同的客户端直接返回不同的数据。第 3 个是因为用户界面往往是发生变化最多的地方，我们不应该是长期而精密地去预先计划页面长什么样子，这是不显示的，而是随着市场需求的变化，产品需要持续的优化和迭代我们的用户界面，此时快速应对页面变化的效率也就至关重要啦。

不知道刚刚对 GraphQL 的介绍，有没有给大家带来一些新的灵感呢？这个时候你可能不由得好奇，咦，我该如何去使用 graphql 呢？所以让我们进入第二部分，介绍 graphql 的工程实践经验，我会从以下 4 个方面来介绍 graphq 的真实实践。首先是使用 relay 作为 graphql 客户端，来请求 graphql 的后端 API，当然在 graphql 查询当中会用到 dataloader 来进行缓存优化，以及 graphql 和 dataloader 是如何解决 N+1 查询问题的。最后呢，我们 Parabol 的产品其实是 realtime 多人协同的，所以我们会用 GraphQL 的订阅能力，来满足实时协同的需求。

接下来关于 How 的部分，可能会比较干货，我尽可能使用一些案例和代码来作为解释。首先，我们来看 GraphQL 如何进行数据请求？类比一下，graphql 相当于“图数据库”的单一入口，大家可以简单这样理解，严谨一点，我加了一个引号啦。只需要访问这样一个入口，发送你想要的数据的查询语句，就能直接拿到对应的数据了。非常简单的单一端点 /graphql，再加上多样化的查询方式。

总的来说， graphql 的运行环境当中，有以下 3 种操作：首先是 query 用于读取数据以及 mutation 用于写入数据，也就意味着 graphql 它既可以是查询、读操作，也可以是修改、写操作，以及 subscription 订阅操作，可以用来自动地接收实时数据。Realtime 实时性在疫情大背景这样的一个环境下是非常有必要的，用于满足在线协同的产品需求，接下来我会逐一介绍 GraphQL 的 query 查询、mutation 修改和 Subscription 订阅的实践经验。

首先，发送 GraphQL API 请求需要一个客户端，我这里会使用 Relay 作为示例。可能如果有实践过 graphql 的朋友，应该会使用 Apollo，也就是另外一个 graphql 客户端会比较多。所以，我简单地介绍一下 relay，Relay 其实是 Facebook 官方推出的一个 framework，也就是一个用来请求和管理 GraphQL 数据的框架。Relay 跟 Apollo 阿波罗的区别在于，Relay 包含了运行时和编译时，它会有一个编译时并且是使用 Rust 写的一个编译器，速度非常快，而且 Relay 会在编译时暴露非常多的编译问题，从而避免出现大量的 bug，比如说类型判空之类的问题。从我们实践的经验来看，结合 TypeScript，几乎所有遇到的问题在编译时就能够被发现并解决。

而这里提到的 hook，则是因为 React hook 是 React 社区主推的一种代码复用的方式。 hook 简单理解就是 functions 函数，用于跟 React 状态和生命周期“打交道”。那么 hook 简直译过来就是钩子，你可以想象把 graphql 的请求数据从 state 状态里面直接勾出来，并且自动化地处理生命周期相关的一些脏活。

接下来我会 4 个实践案例，首先进入到第 1 个实践，使用 useFragment 数据片段，前面提到，GraphQL 是一门查询语言，我们可以分段分片片段的去查询，所以它在这里叫做 fragment 也就意味着我可以声明片段，每个组件可以只声明自己所需要的数据需求就可以了。我们可以看到右边这样简单的图例，这里会有头像和名称，以及下面的简介，接下来是一些额外的 agenda 信息，日程安排的信息。那么在左边就是这样 graphql 的，不组件的组件数，所以说每个组件它都在内部定义自己的需求，数据需求就可以了。那么在最顶层这些组件可以由请求就一次性把所有的 graphql 数据都请求回来了。那么这也就意味着每个组件都在独立的 query 自己的数据最终会由 relay 自动化的去合并发送请求。这样每组件就只需要关心自己所定义的数据就可以了。

首先另外还有一点，如果我们组件级别已经把数据片段定义完毕，那在其他地方如果有复用该组件所需要的代码片段的时候，数据片段的时候就可以直接在上一层进行复用即可，所以它也就能够实现代码共享。前面也已经提到了 relay 它最大的特点就是有 compiler 编译器，它可以自动解析重复的字段。比方说前面提到的头像和下面的内容，两个组件它都用到了这样字段对吧？那这样字段，它会在最终合成的 query 请求当中自动被合并成字段了。

所以前面我们提到 fragment 就是用来定义数据片段的请求需求，而最终由 GraphQL 自动化的去生成这样 query query 是支持将这里的片段子组件的片段合并到大型的整体的 query 而合成操作并不需要我们自己去完成它，而是 relay 自动化的就帮我们做到了。

好，那么我们复盘来看一下的话，当我们的页面上有这样大型的组件树时，因为我们的页面是由组件树所构成，我们就可以看到最上方会有导航栏，左边会有个侧边栏，中间会有 banner 和右边的 set bar 以及中间部分的内容信息流。这样组件树就可以由 relay 自动地去获取到每组件所需要的数据型需求，并且在顶层也就是 home 组件级别进行一次性的数据请求。

数据的 request 在 RE request 访返回数据成功之后，它会自动化的将每 fragment 所需要的 data 也就是刚刚我们提到 hook 所返回来的 data 直接分发给每组件，从而每个组件对吧就都拿到了自己的数据。

我们可以看到这里的 post API post 组件，它只需要定义 use fragment 以及加上 graphql 的 fragment 的模板字符串，从而就可以拿到对应的 data data 我们就可以直接在下面点 title 或者点 body 就能够取到对应的 fragment 里面所定义的数据结构了。这里定义了 title 和 body 所以接下来在组件当中就可以通过 data 点巴拉巴拉及时的去使用它了。

Pre loaded query.加上前面所定义的 graphql 的查询语句以及查询语句的引用，从而我们就可以拿到对应的 data 和 data 里面的 post post 就可以在我们刚所定义的组件里面就是直接使用到它。

好，那时候我们来具体看例子，会刚刚直接看代码会有点懵，所以我会逐一的用例子来大家演示，为什么要这样做？首先我们来讲这样显示 post 显示推文这样。这样例子。我们可以看到之前我们是在请求数据，渲染页面，再请求数据场景。

我们可以回顾来看一下这样 feature on render 的 loading 加载序列。 feature on render 可以理解成在渲染之后再请求数据。于是乎我们需要先下载代码渲染 home 组件，再去请求后端的数据。此时我们可以看到我们在请求数据回来之前，我们就不得不去 render feedback fall back 也就是 loading 的那个圈圈的效果。在所有的数据完成之后，我们才能够看到 home 组件被成功渲染出来。所以我们可来看一下渲染示例，这里会有长时间的空白。加载数据，加载数据加载到一半，发现中间组件还需要继续加载更多的数据，于是才能显示出来。

而我们刚刚提到的加上 suspense 之后，也就意味着我们使用的是 render as you fetch 也就意也就是边渲染边获取数据，从而序列就变成了我们首先请求数据，请求数据的同时，我们就可以进行 loading 效果的显示了。

在渲染结束之后，我们可以看到这里的 profile 页面也就被显示完毕，后续只需要加载图片就可以了。那么我们可以看一下它的渲染过程，就是先看到空白，直接整个组件数全部一次性的就被显示出来了。可以看下显示 loading 的效果，显示所有的内容，体验会比刚刚，再加上 loading 图标的过程要好得多。

那么我时间有限，我们就进入第三个实践，也就是 graphql 如何解决 N 加 1 查询问题？我们使用 graphql 的方式来思考问题的话，我们可以对比来看，左边是 rest API 进行的 N 加 1 请求，我们先拿到所有的 stories 可以理解成所有的故事点，再把这些故事卡片逐一地去获取对应的细节。

方说这里拿到每 story 之后，再根据 story 的超链接去获取 story 的具体细节，比方说它的具体描述是什么。而在 graphql 里面，我们只需要一次性请求，就通过 query 画括号 stories 里面去定义 stories 所对应的 ID 和 text 就可以一次性直接返回 story item 的列表。

那个 user query 的方式去查询 GraphQL 所对应的数据，以及我讲了具体的 suspense 加载序列的优化问题，并且介绍了边获取边渲染提高用户体验的方式。另外就是 N 加 1 请求查询，在 graphql 里面使用 dataloader 进行了优化，以及刚刚讲到 subscription 是允许了多个查询同时即时的返回 dataloader 给每订阅者，从而每个订阅者可以直接使用它快速的返回对应的数据。

好，那么接下来就进入到 graphql 的真实用案例，我会从身份验证嵌套认证。因为我们需要去集成 rest API 角度来给大家介绍身份验证和嵌套认证，以及我们去修改 github 的 API 因为我们作为会议软件产品，需要跟第三方的像是 JIRA 或者是 github GitLab 第三方 API 打交道，所以我们会有一定的优化。

这里面还有彩蛋，接下来会给大家介绍。那么首先这样，第场景就是敏捷会议工具 springparker 这样产品。这样形态大家在之前的会议当中应该已经用过了，就是我们在给每一张在迭代开始之前给每卡片估点的时候，会采用扑克牌的方式来对一张卡进行估点。所以说我们就相当于把会议形态搬到了线上，并且以一种实时的方式允许每开发对其进行估点，从而自动计算出投票结果。

拿到 assets token 之后，可以给它设定失效时间，失效时长，并且在失效时间内，我们就直接去直接返回了 token 那如果说它是在失效时间之外，也就是超已经失效了，那么我我们就会去请求新的 token 当然 token 可以根据之前的 refresh token 直接去向 rest API 请求新的 token 并且返回对应的更新时间，从而我们就可以拿到 A 每授权信息去请求 JIRA 里面所有的故事点啦。

好，那么第二个案例就是在嵌套查询里面怎么样去复用查询信息，因为 rest API 它是有前面我们说到的缺点的。比方说这里我们同时需要去取到 JIRA 所返回回来的一些用户信息、团队信息和任务信息。那么每 API 是不是都需要这样 rest API 的授权信息呢？所以说我们就直接在这新建 dataloader 从而在查询 JIRA 的 issue 的时候直接拿到对应的授权信息给每 manager manager 再去请求对应的 issue 也就是 JIRA 里面的故事点。那拿回来之后就做 map 进行统一的数据处理。

第二个是 query 查询 github 的 graphql API 因为 github 的 API 就是 query graphql 支持的 API 那么这里面直接通过 github 的 schema 就能够拿到 github API 里面的 query 里面的 user 的相关信息。

那这是怎么做到的呢？你可以看到它非常的简单，我们只需要输入 user 的当前 query 的 github 的 API 数据，也可以去拿到用户下面的所有子任务，并且它也是可以复用 user 的头像信息的这样代码片段的，所以说可以一次性把后面的几个数据全部返回来。

而这里面有隐含的条件就是所有的 user 下面的 github API 它是集成了三分的 API 的，而集成相当于做了大一统。而大一统是由 Parabol 的开源项目 nest graphqa endpoint 来实现的。因为以往你不在 graphql 的 API 里面内嵌其他的 graphql 的 API 对吧？那么在使用了这样开源库之后，我们就可以得到 merge 的 schema merge 的 schema 就可以同时显示在我们的代码文档里面。我们可以通过文档活文档直接查询到 github 里面有哪些 API 字段，也可以返回，也可以查询我们自己的应用的 API 字段，从而使用 merge 的 schema 并且仿定义它所取的 github 的 API 名字。话我们就可以直接使用它了，是不是变得非常简单？如果大家感兴趣的话，可以通过地址点到我们的 github 的开源项目地址给大家。如果能加上 start 就更好了。

那么除此之外，顺便提一句我们公司的所有代码，包括主应用的代码都是开源的。说到这里，需要进入到我们最后的总结部分啦。 graphql 和异步协作前面也提到我们所有的代码都是开源的。另外我们的所有的团队也是全球分布式的这张图是，但这张图里面没有我，这张图里面是非常有代表性的，每人都拿着自己的护照，也就意味着我们所有的开发人员、产品人员都是来自于不同的地区，来自于不同的州。所以带来的潜在的两个问题，是跨地区，大家必须全面的远程办公。第二个是跨时区，大家在沟通的时候只能采取异步协作的方式，就你发了消息，我不一定今天就能够看到。所以说这给我们的开发带来了好处，也带来了一些不便之处。

在我今天演讲的话题里面，我想给大家讲一下 graphql 是怎么样对异步协作有所帮助的。比方说第，比方说我们这里会有 github 的。不，graphql 的活文档左边是 explore 就是我们可以通过字段的 schema 定义来找到所有的字段的名称和它所对应的数据结构，中间则是 query 这 query 呢可以通过你所定义的 schema 获取到对应的返回数据，数据都是可预期的结构，直接返回回来了。

那么我们可以看到这样文档，它在实践的时候会有什么样好处呢？首先它是减少了前后端来回沟通的成本。那么因为所有的 API 我们都可以从前端直接定义它的数据结构，并且直接返回回来。这就不再需要说我今天需要前端说今天需要开发页面，需要等待后页面后端 API 的完成，从而我前端就可以直接按需的返回自己所需要的数据，并且在整个页面层级只需要访问 API 除此之外，每组件都可以去定义自己的数据需求片段，片段也是可以自由组合的，也就是意味着每开发同学只需要去定义自己所需要的组件的数据就可以了，尽的减少了不必要的沟通。而所谓的这些 fragment 的自由组合和聚合以及分发数据的分发，那都是由 relay 这样编译器自动化的去实现。它的第二个就是 API 更新，它不及时甚至没有文档。那么时候这是困扰我们大多数前端前后端协同开发时的头痛的地方。明明我已经定义了 API 数据结构，那数据结构发生变化之后，我又得反复不断地去通知前端同学。

我这有个文档子上的更新，并且很多时候更新并不可怕，可怕的是你更新了哪个字段以及哪个字段，它的数据类型发生了变化，从而导致了很多不必要的 bug 因为在 RE 传统的 rest API 当中，每个字段它是没有数据类型的定义的。这也就意味着我把 number 从原有的 int 类型直接改成了 string 类型。那时候前端因为没有做适当的格式化，导致不必要的 bug 另外那么所有所以如果说文档更新不及时，甚至没有文档，那还不如不写文档对吧。

那么在 graphql 这样场景下，当我们把 graphql 的 schema 定义完成之后，我们就相当于有了活文档了。而活文档可以直接有直观的好处。你不需要去写文档，而文档对于所有人都是可访问的。可缓问。我举个小例子，比方说我们的销售同学也是可以直接用文档来做一些权限的控制处理的。比方说对于一些企业用户，他需要有一些更新的。 Future.或者是比方说有我们最近在开发新的 stand up 功能，在做市场推广的时候，我们可以手动的通过方式去给客户开启对应的权限。那么我们的销售人员就可以直接不仅有任何开发人员的帮助，就能够在文档上面完成他所需要的工作。所以说文档的使用成本是非常之低的，所有人都是可访问可使用的。

最后我想强调概念叫做使用代码直接来沟通对吧。当我们少却了不必要的很多冗余的沟通以外，我们真正需要沟通的地方就会变得少了很多。我们直接定义好 schema 以及 schema 是如何处理对应的数据结构以及这些 mutation 的具体操作是什么样的，都可以直接在 schema 上就表现出来了，体现出来了。而我们正常的使用代码进行提交时，会产生对应的 prrequest 而所有的开发人员就基于 request 所提交的代码进行直接的反馈评论，话是大大加速了我们开发的过程的。所以说 schema 优先一定是未来的研发模式之一。

总结下来，异步协作需要大量我们的软件开发是一场社会活动，而社会活动需要大量的沟通，沟通是可以同步也可以异步的。而我们这样分布式的团队，在沟通时采用 schema 优先的这种异步方式会大大改进我们的沟通效率，并且异步带来的其他好处大家已经不言而喻了，因为作为开发人员，相信你们最讨厌的也就是开会。

如果有同感，可以看明天早上小波老师的另外一群人讲他是如何去分享自己在分布式团队当中探索异步协作的方法。方式党好，那么今天所有的分享内容就到这里啦，我们可以我们可以看到最开始按需返回数据，就解决了沟通的问题。单 GraphQL 可以解决按需加载数据的问题，以及我介绍了 graphql 在时间当中有不同成的介绍了四个关于 graphql 的具体工程实践经验，以及四个应用具体真实的应用场景。那么相对来说 graphql 在国内的使用成频率还不是那么高。

所以说如果大家对 graphql 对 API 的未来以及对敏捷组织如何快速迭代感兴趣的话，可以加我的微信。那另外这里也特别感谢 K 加峰会的组织和安排，我也从这次会议当中学到了非常多的东西，希望跟大家有更深度的一些交流。那么我们的今天讲就到这里，谢谢大家。
